Essentially the program encrypts a given file byte by byte using a reversible and chaotic transformation.  

You may want to check out [this YouTube video by Veritasium](https://youtu.be/ovJcsL7vyrk) and [this textbook by Strogatz](https://books.google.co.in/books?id=wUBvDwAAQBAJ&lpg=PT7&ots=ANvcUvkPyR&dq=strogatz%20nonlinear%20dynamics%20and%20chaos&lr&pg=PA1#v=onepage&q&f=false) for learning more about the logistic map and chaos.  

In summary, if you iterate <img src="https://render.githubusercontent.com/render/math?math=x' = rx(1-x)"> by giving an initial value of x, obtaining a value of x', and feeding it back in place of x, and so on; you will find that for certain values of r, specifically in the range 3.6 < r < 4, the iterated values are seemingly random. Furthermore, maps that begin with nearby initial conditions eventually diverge (this is the essence of chaos). The same happens to be true for any unimodal (having a single hump) mapping function, albeit for a differnt range of r specific to that map.  

Here I use a mapping function <img src="https://render.githubusercontent.com/render/math?math=x' = rx^p(1-x)^q"> (p and q are parameters) to quickly generate reproducible random numbers that are then used to encode a given byte. A particular chain of random numbers can be completely and uniquely defined by a set of numbers (x, t, p, q, r) where x is the first input to the map and t is the number of outputs discarded from the beginning of the chain.  

The key is expanded as follows  
* A user input array of characters constituting the passkey is first converted to an array of bits.
* 16 bits are picked out and converted to an integer, and then to a float between 0 to 1 to obtain a value for the variable gamma.
* The number of coefficients (minimum 2) is determined based on the number of bits remaining.
* '1's are inserted at the approcimate middle of the bit array to make its length an integer multiple of the number of coefficients
* For each coefficient, a number of bits, again depending on the length of the key, are picked out and converted to integers representig the 't' parameter for that coefficient
* The remaining bits are distributed into chunks and each chunk is converted to a float between 0 to 1 to obtain the 'x' parameter, and using pre-defined limits,  the 'p', 'q' and 'r' parameters.  

During encryption, a byte, in the form of an unsigned 8 bit integer, is converted to a float by dividing it with 256.0. Then it is raised by a number gamma between 0 and 1 (this helps in better hiding of the data in the case of images). This number is then used as an input to a polynomial whose coefficients are random numbers generated by the aforementioned procedure. The degree of the polynomial, one less than the number of coefficients, is determined by the length of the key. The output of the polynomial function is normalized to make sure that the final number lies between 0 and 1. It is then written as a base-256 number in the form of a character array whose length depends on the degree of the polynomial.

The polynomials are defined as (strictly speaking, they are actually not polynomials when the degree is higher than 2)
* Degree = 1: <img src="https://render.githubusercontent.com/render/math?math=z=y_0f%2By_1">  
* Degree = 2: <img src="https://render.githubusercontent.com/render/math?math=z=(y_0f%2By_1)^2%2By_2">  
* Degree = 3: <img src="https://render.githubusercontent.com/render/math?math=z=((y_0f%2By_1)^2%2By_2)^{(3/2)}%2By_3">  
* and so on  
Here, each of the y's is generated from a mapping defined from the key in terms of a combination (x, t, p, q, r), iterated every time a new byte is encrypted.  

During decryption, the entire process is reversed. If the length of the entered password is different from the actual password, the base-256 numbers are read incorrectly. If the length of the key does match, but the actual characters are different, even by just a single character, the resulting coefficients of the polynomials are quite different, thanks to the chaotic nature of the mapping function. Therefore the only way to retrieve the data is by using the correct key.  

The name of the original file is also appended at the beginning of the encrypted file so that it can later be retrieved in case the encrypted file is renamed.
